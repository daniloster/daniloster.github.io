{"version":3,"sources":["webpack:///./src/articles/Closure.js"],"names":["codeTheme","Article","brief","html","theme","code","trim","lang","href","target"],"mappings":"2FAAA,gJAQMA,EAAY,QAEH,SAASC,EAAT,GAAmC,IAAVC,EAAS,EAAfC,KAChC,OACE,6BACE,kBAAC,UAAD,KAAOD,GACP,kBAAC,UAAD,sLAKA,kBAAC,UAAD,+LAKA,kBAAC,UAAD,gCACA,kBAAC,UAAD,kDACA,kBAAC,UAAD,gGAIA,kBAAC,UAAD,CACEE,MAAOJ,EACPK,KAAM,mWAaFC,SAEN,kBAAC,UAAD,qDACA,kBAAC,UAAD,CACEF,MAAOJ,EACPO,KAAK,QACLF,KAAM,mKASFC,SAEN,kBAAC,UAAD,+CACyC,wDAAiC,IAD1E,sDAEsD,IACpD,6CAHF,8EAMA,kBAAC,UAAD,mBACA,kBAAC,UAAD,sFAEU,IACR,kBAAC,UAAD,CAAGE,KAAK,4CAA4CC,OAAO,UAA3D,YAEK,IALP,8IASA,kBAAC,UAAD,gDAC0C,iDAD1C,0CAEmC,uCAFnC,6CAKA,kBAAC,UAAD,CACEL,MAAOJ,EACPK,KAAM,wZAaFC,SAEN,kBAAC,UAAD,iBACW,iDADX,uLAIU,wCAJV,IAI2B,wCAJ3B,KAI6C,oCAJ7C,iCAKuB,gDALvB,4CAMkB,uCANlB,cAQA,kBAAC,UAAD,wBACA,kBAAC,UAAD,0UAOA,kBAAC,UAAD,KACE,kBAAC,UAAD,CACEE,KAAK,mEACLC,OAAO,UAFT,gBAMA,kBAAC,UAAD,CACED,KAAK,kFACLC,OAAO,UAFT,qCAMA,kBAAC,UAAD,CAAGD,KAAK,4CAA4CC,OAAO,UAA3D","file":"8-8820fb0d29b5fe940af8.js","sourcesContent":["import React from \"react\"\nimport Paragraph from \"../templates/components/Paragraph\"\nimport Subtitle from \"../templates/components/Subtitle\"\nimport References from \"../templates/components/References\"\nimport A from \"../templates/components/A\"\nimport Code from \"../templates/components/Code\"\nimport Html from \"../templates/components/Html\"\n\nconst codeTheme = \"prism\"\n\nexport default function Article({ html: brief }) {\n  return (\n    <div>\n      <Html>{brief}</Html>\n      <Paragraph>\n        To understand closures completely, we need to understand the scopes as\n        well. Javascript has the lexical scope (a.k.a. static scope) which is\n        defined during compilation time.\n      </Paragraph>\n      <Paragraph>\n        The lexical scope is inferred in the lexical analysis performed by the\n        JS compiler. The variables and functions can only be directly referenced\n        inside the scope in which is declared.\n      </Paragraph>\n      <Paragraph>See following examples.</Paragraph>\n      <Subtitle>Private variable (through object factory)</Subtitle>\n      <Paragraph>\n        A good usage for closure is creating factories to create object with\n        private variables.\n      </Paragraph>\n      <Code\n        theme={codeTheme}\n        code={`\nfunction factoryUser(username, firstname, lastname) {\n  const user = {\n    firstname,\n    lastname,\n    getUsername: () => username;\n  };\n\n  return user;\n}\n\nconst userWithReadonlyUsername = factoryUser(\"party@home\", \"Sweet\", \"Home\");\nconsole.log({ userWithReadonlyUsername, username: userWithReadonlyUsername.getUsername()  });\n          `.trim()}\n      />\n      <Paragraph>The output for the given example would be...</Paragraph>\n      <Code\n        theme={codeTheme}\n        lang=\"shell\"\n        code={`\n{\n  userWithReadonlyUsername: {\n    firstname: \"Sweet\",\n    lastname: \"Home\",\n    getUsername: [Function],\n  },\n  username: \"party@home\",\n}\n          `.trim()}\n      />\n      <Paragraph>\n        It is very important to understand the <b>lifecycle of the variable</b>{\" \"}\n        when a closure is created. Recklessness can lead to{\" \"}\n        <b>memory leaking</b>. So, pay attention to remove references when they\n        are not needed anymore.\n      </Paragraph>\n      <Subtitle>Decorators</Subtitle>\n      <Paragraph>\n        It is the ability of adding a behaviour to a function without changing\n        it. So,{\" \"}\n        <A href=\"https://javascript.info/currying-partials\" target=\"_blank\">\n          currying\n        </A>{\" \"}\n        is an example of decoration which would return a new function and some\n        of the previous function's arguments are predefined in the closure.\n      </Paragraph>\n      <Paragraph>\n        Another classic example is creating the <b>mapDisaptchToProps</b> from\n        redux. There is a combination of <b>dispatch</b> function with the\n        arguments and payload.\n      </Paragraph>\n      <Code\n        theme={codeTheme}\n        code={`\nconst increment = () => ({ type: 'INCREMENT' })\nconst decrement = () => ({ type: 'DECREMENT' })\nconst reset = () => ({ type: 'RESET' })\n\nfunction mapDispatchToProps(dispatch) {\n  return {\n    // dispatching plain actions\n    increment: () => dispatch({ type: 'INCREMENT' }),\n    decrement: () => dispatch({ type: 'DECREMENT' }),\n    reset: () => dispatch({ type: 'RESET' })\n  };\n}\n          `.trim()}\n      />\n      <Paragraph>\n        Once the <b>mapDisaptchToProps</b> is called, its scope will be\n        partially retained as there is a reference to one of its variable. Yes,\n        the parameters are variable to the function. Then, while the function\n        created <b>increment</b>,<b>decrement</b>, <b>reset</b> are not\n        collected by the CG (<i>Garbage Collector</i>), the closure will live\n        referencing the <b>disaptch</b> argument.\n      </Paragraph>\n      <Subtitle>Given and taken</Subtitle>\n      <Paragraph>\n        Closures are pretty powerful but its unnecessary usage can lead to\n        problems as memory leaking or degrading performance. Keep in mind that\n        you are creating a living context where some references are kept to be\n        used in the future by a function created from its context. Then, making\n        a clear flow for GC is really important.\n      </Paragraph>\n      <References>\n        <A\n          href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures\"\n          target=\"_blank\"\n        >\n          MDN Closures\n        </A>\n        <A\n          href=\"https://medium.com/javascript-scene/curry-and-function-composition-2c208d774983\"\n          target=\"_blank\"\n        >\n          Currying and function composition\n        </A>\n        <A href=\"https://javascript.info/currying-partials\" target=\"_blank\">\n          Currying and partials\n        </A>\n      </References>\n    </div>\n  )\n}\n"],"sourceRoot":""}