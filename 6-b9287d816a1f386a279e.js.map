{"version":3,"sources":["webpack:///./src/articles/BehindTheStateManagement.js"],"names":["codeTheme","Layout","styled","div","Article","brief","html","href","target","theme","code","trim"],"mappings":"6FAAA,gJAQMA,EAAY,QAEZC,EAASC,IAAOC,IAAV,mFAAGD,CAAH,gZAmDG,SAASE,EAAT,GAAmC,IAAVC,EAAS,EAAfC,KAChC,OACE,kBAACL,EAAD,KACE,kBAAC,UAAD,KAAOI,GACP,kBAAC,UAAD,yUAOA,kBAAC,UAAD,8BACA,kBAAC,UAAD,8OAKA,kBAAC,UAAD,gGAGA,kBAAC,UAAD,+KAIA,kBAAC,UAAD,qdAOA,kBAAC,UAAD,0dAKqE,kBAAC,UAAD,CACjEE,KAAK,2DACLC,OAAO,UAF0D,qBALrE,sDAYA,kBAAC,UAAD,qCACA,kBAAC,UAAD,kNAGU,kBAAC,UAAD,CAAGD,KAAK,+EAChBC,OAAO,UADC,iBAHV,6DAMK,kCANL,QAMoB,kCANpB,iDAQA,kBAAC,UAAD,qIAE6B,8DAA4C,IACvE,kBAAC,UAAD,CAAGD,KAAK,8DACRC,OAAO,UADP,OAHF,IAKW,kBAAC,UAAD,CAAGD,KAAK,yFACjBC,OAAO,UADE,OALX,oRAYA,kBAAC,UAAD,0JAEgD,8DAFhD,0BAGW,6DAHX,IAGsD,kBAAC,UAAD,CAAGD,KAAK,wFAC1DC,OAAO,UAD2C,OAHtD,IAKW,kBAAC,UAAD,CAAGD,KAAK,+DACfC,OAAO,UADA,OALX,6HAWA,kBAAC,UAAD,sCACA,kBAAC,UAAD,6CACA,kBAAC,UAAD,2BACA,kBAAC,UAAD,CACEC,MAAOT,EACPU,KAAM,iZAmBJC,SAEJ,kBAAC,UAAD,6HAIA,kBAAC,UAAD,kDACA,kBAAC,UAAD,qFACA,kBAAC,UAAD,CACEF,MAAOT,EACPU,KAAM,mlBAwBJC,SAEJ,kBAAC,UAAD,yEACA,kBAAC,UAAD,CACEF,MAAOT,EACPU,KAAM,k6BAgCJC,SAEJ,kBAAC,UAAD,kFACA,kBAAC,UAAD,iNAIA,kBAAC,UAAD,0CACA,kBAAC,UAAD,CACEF,MAAOT,EACPU,KAAM,ySAUJC,SAEJ,kBAAC,UAAD,kHAEQ,IAFR,0BAEoC,QAAS,IAF7C,2OAMA,kBAAC,UAAD,uEACA,kBAAC,UAAD,oBACA,kBAAC,UAAD,CACEF,MAAOT,EACPU,KAAM,wxBAsBJC,SAEJ,kBAAC,UAAD,sBACA,kBAAC,UAAD,CACEF,MAAOT,EACPU,KAAM,gmCAmCJC,SAEJ,kBAAC,UAAD,+CACA,kBAAC,UAAD,2RAKA,kBAAC,UAAD,wKAIA,kBAAC,UAAD,sBACgB,kBAAC,UAAD,CACZJ,KAAK,qEACLC,OAAO,UAFK,iDADhB,KAOA,kBAAC,UAAD,KACE,mCADF","file":"6-b9287d816a1f386a279e.js","sourcesContent":["import React from \"react\"\nimport styled from \"styled-components\"\nimport A from \"../templates/components/A\"\nimport Code from \"../templates/components/Code\"\nimport Html from \"../templates/components/Html\"\nimport Paragraph from \"../templates/components/Paragraph\"\nimport Subtitle from \"../templates/components/Subtitle\"\n\nconst codeTheme = \"prism\"\n\nconst Layout = styled.div`\n  .wrapper {\n    border: 1px dotted darkgrey;\n    padding: 15px;\n  }\n\n  .wrapper + .wrapper {\n    margin-top: 15px;\n  }\n\n  .container {\n    position: relative;\n    height: 200px;\n    width: 200px;\n    background-color: blue;\n  }\n\n  .container > div {\n    /* either */\n    width: 100%;\n    /* or width: 200px; */\n    background-color: green;\n  }\n\n  .content-box {\n    box-sizing: content-box;\n  }\n\n  .padded {\n    /* this means 10px each direction (top, right, bottom, left) */\n    padding: 10px;\n  }\n\n  .bordered {\n    /* this means 5px each direction (top, right, bottom, left) */\n    border: 5px solid red;\n  }\n\n  .with-margins {\n    margin: 10px;\n  }\n\n  .overflow {\n    overflow: auto;\n  }\n\n  .border-box {\n    box-sizing: border-box;\n  }\n`\n\nexport default function Article({ html: brief }) {\n  return (\n    <Layout>\n      <Html>{brief}</Html>\n      <Paragraph>\n        There are several ways out there to provide a store mechanism to share data in frontend\n        applications in diverse UI frameworks. There is always a trend on new store management\n        that does something slightly different. The goal  of this post is to demystify the\n        “complexity” of state management by implementing one in React.\n      </Paragraph>\n      \n      <Subtitle>Reasoning About State</Subtitle>\n      <Paragraph>\n        Let’s understand what an application requires from state management indeed. Maintaining a state\n        imply in providing ways for components and “interested parts” to subscribe to changes, to obtain\n        the current state, and to update it.\n      </Paragraph>\n      <Paragraph>\n        Ideally, the store should be a replaceable piece being decoupled from your application.\n      </Paragraph>\n      <Paragraph>\n        Now that we understand the basic requirements of a store, why should we implement one while\n        we have several libraries doing it already? There are 2 entangled reasons.\n      </Paragraph>\n      <Paragraph>\n        1st. The node environment is extremely polluted causing an application to take huge space on\n        the disk (above 1Gb certainly). Having a large node_modules folder will likely have more files\n        that will be loaded while compiling or running your application, therefore, slowing down some of\n        the development lifecycles (development, testing, building, deplyoing among others) or adding security\n        risks. Then, preventing the usage of unnecessary libraries is essential.\n      </Paragraph>\n      <Paragraph>\n        2nd. Not all things we imagine being complex are complex indeed. If you revisit your past there\n        will be things you found complex as hell that make you laugh today. As we experience more challenges\n        and events in life we gather more knowledge and connect some dots making something for a second time\n        easier in some cases. We should only add libraries to the node environment if it is really required,\n        and when the library is solving a complex task. I would ask you to <A\n          href=\"https://signalvnoise.com/posts/3124-give-it-five-minutes\"\n          target=\"_blank\"\n        >\n        give it 5 minutes</A> for this suggestion before stating it is complex.\n      </Paragraph>\n\n      <Subtitle>Design Patterns &amp; Principles</Subtitle>\n      <Paragraph>\n        Based on the requirements described before, we need to provide ways to update and get a value.\n        We have seen a lot of this when studying paradigms such as OOP (Object-Oriented Programming) where\n        we used <A href=\"https://medium.com/javascript-scene/encapsulation-in-javascript-26be60e325b4\"\n        target=\"_blank\"\n        >encapsulation</A> and discretely allowed other parts of the application\n        to <i>get</i> and <i>set</i> values under certain circumstances of scope.\n      </Paragraph>\n      <Paragraph>\n        Making the Glue. Now, the application or different modules need to be notified whenever the store\n        changes. That is where the <strong>Subject (Observer pattern)</strong>{' '}\n        <A href=\"https://www.dottedsquirrel.com/observer-pattern-javascript/\"\n        target=\"_blank\"\n        >[1]</A> <A href=\"https://medium.com/@majdasab/observer-pattern-with-javascript-es6-classes-2a19851e1506\"\n        target=\"_blank\"\n        >[2]</A> comes to the rescue. If you\n        have worked with event-driven applications or observables, you may be familiar with its usage. Creating\n        the “update subject” and notifying all subscribed parts on every valid set will allow components to be\n        in sync with the shared/global data.\n      </Paragraph>\n      <Paragraph>\n        Last but not least, the store should have a contract that allows you, as a developer, to replace it\n        at any time. This is the design principle for <strong>IoC (Inversion of Control)</strong>, or commonly\n        known as <strong>DI (Dependency Injection)</strong> <A href=\"https://medium.com/backticks-tildes/the-s-o-l-i-d-principles-in-pictures-b34ce2f1e898\"\n          target=\"_blank\"\n        >[1]</A> <A href=\"https://itnext.io/dependency-injection-in-react-6fcdbd2005e6\"\n          target=\"_blank\"\n        >[2]</A>. The usage of DI decouples your application from\n        the state making it way easier to replace/upgrade/test the application.\n      </Paragraph>\n\n      <Subtitle>Implementing State Management</Subtitle>\n      <Paragraph>Now let’s assign theory to practice.</Paragraph>\n      <Paragraph>1st. Encapsulation</Paragraph>\n      <Code\n        theme={codeTheme}\n        code={`\nfunction isValid(value: any): boolean {\n  return value !== undefined && value !== null;\n}\n  \nexport class State<T> {\n  private state: T = null!;\n  \n  constructor(state: T) {\n    this.set(Object.freeze(state));\n  }\n  \n  get = (): T => this.state;\n  \n  set = (state: T): T => {\n    this.state = isValid(state) ? Object.freeze(state) : state;\n    return this.get();\n  };\n}\n        `.trim()}\n      />\n      <Paragraph>\n        Here is our state with “get” and “set”. In addition, we make sure the object set is always immutable\n        by freezing it.\n      </Paragraph>\n      <Paragraph>2nd. Subject Pattern and Making the Glue.</Paragraph>\n      <Paragraph>Creating our Subject class, the mechanism of subscription, and notification.</Paragraph>\n      <Code\n        theme={codeTheme}\n        code={`\nexport class Subject<T> {\n  private subscriptions: Array<Subscription<T>> = [];\n  \n  subscribe = (subscriber: Subscription<T>): Unsubscribe => {\n    const reference = { ...subscriber };\n    this.subscriptions.push(reference);\n    return () => {\n      this.subscriptions = this.subscriptions.filter(\n        (item) => item !== reference\n      );\n    };\n  };\n  \n  next = (value: T) => {\n    this.subscriptions.forEach(({ next }) => void next(value));\n  };\n}\n\nexport type Unsubscribe = () => void;\n  \nexport interface Subscription<T> {\n  next(state: T): void;\n}\n        `.trim()}\n      />\n      <Paragraph>Using Subject to make the glue and creating an observable state.</Paragraph>\n      <Code\n        theme={codeTheme}\n        code={`\nimport { State } from \"./State\";\nimport { Subject, Subscription, Unsubscribe } from \"./Subject\";\n  \nexport type Transformer<T> = (value: T) => T;\n  \nexport class ObservableState<T> {\n  private state: State<T>;\n  private subject: Subject<T> = new Subject();\n  \n  constructor(value: T) {\n    this.state = new State(value);\n  }\n  \n  get = (): T => this.state.get();\n  \n  set = (transform: Transformer<T>): T => {\n    const oldValue = this.get();\n    const newValue = transform(this.get());\n    const hasChanged = newValue !== oldValue;\n    if (hasChanged) {\n      this.state.set(newValue);\n      // In order to create an async behaviour, let’s make usage of setTimeout\n      setTimeout(() => void this.subject.next(this.get()), 0);\n    }\n    return this.get();\n  };\n  \n  subscribe = (subscription: Subscription<T>): Unsubscribe => {\n    return this.subject.subscribe(subscription);\n  };\n}\n        `.trim()}\n      />\n      <Paragraph>That is our observable state created with 3 files. So, how to use it now?</Paragraph>\n      <Paragraph>\n        The application needs to state management mechanism should define a contract and provide a way to\n        replace it. Typescript can help with the contract and the React.Context with the Dependency Injection.\n      </Paragraph>\n      <Paragraph>Contract and Dependency Injection</Paragraph>\n      <Code\n        theme={codeTheme}\n        code={`\nimport { createContext } from \"react\";\nimport { ObservableState } from \"../core/state/ObservableState\";\nimport { PeopleState } from \"../model/PeopleState\";\n         \nexport const PeopleStateContext = createContext(\n  new ObservableState<PeopleState>({\n    people: []\n  })\n);\n        `.trim()}\n      />\n      <Paragraph>\n        Because we define the context with a default valid value, we don’t need to wrap the application with\n        the “{'<'}Context.Provider value={'{...}'}{'>'}”. And you should avoid wrapping the application to\n        facilitate the implementation of tests. When testing, you can wrap the module with any other State\n        matching the contract, allowing you to setup different scenarios for your tests.\n      </Paragraph>\n      <Paragraph>At last 2 examples of consumers: as a state, and as a reducer.</Paragraph>\n      <Paragraph>As a State.</Paragraph>\n      <Code\n        theme={codeTheme}\n        code={`\nimport { Context, useContext, useEffect, useState } from \"react\";\nimport { ObservableState, Transformer } from \"./ObservableState\";\n         \nexport function useObservableState<T>(\n  stateContext: Context<ObservableState<T>>\n): [T, (transform: Transformer<T>) => T] {\n  const observableState = useContext(stateContext);\n  const [state, setState] = useState<T>(observableState.get());\n  \n  useEffect(() => {\n    const unsubscribe = observableState.subscribe({\n      next: (value) => void setState(value)\n    });\n  \n    return unsubscribe;\n  }, [observableState]);\n  \n  // here we want all parts manipulating the state to change the core state\n  // then all other subscribers will get the new value, including this one\n  return [state, observableState.set];\n}\n        `.trim()}\n      />\n      <Paragraph>As a Reducer.</Paragraph>\n      <Code\n        theme={codeTheme}\n        code={`\nimport { Context, useCallback, useContext, useEffect, useState } from \"react\";\nimport { ObservableState } from \"./ObservableState\";\n  \nexport type ReducerTransformer<T, Action> = (state: T, action: Action) => T;\n         \nexport function useObservableStateReducer<T, Action>(\n  reducer: ReducerTransformer<T, Action>,\n  stateContext: Context<ObservableState<T>>\n): [T, (action: Action) => Action] {\n  const observableState = useContext(stateContext);\n  const [state, setState] = useState<T>(observableState.get());\n  const dispatch = useCallback(\n    (action) => {\n      const transform = (oldState) => {\n        const value = reducer(oldState, action);\n        return value;\n      };\n      observableState.set(transform);\n      return action;\n    },\n    [reducer, observableState]\n  );\n  \n  useEffect(() => {\n    const unsubscribe = observableState.subscribe({\n      next: (value) => void setState(value)\n    });\n  \n    return unsubscribe;\n  }, [observableState]);\n  \n  // very similar to the previous hook, but returning a dispatch function\n  return [state, dispatch];\n}\n        `.trim()}\n      />\n      <Subtitle>Behind the State Management Complexity</Subtitle>\n      <Paragraph>\n        Now that we have gone through this journey, I would ask you to sleep on it before defending the complexity\n        of global state or jumping on as a silver bullet definition. In software development, there is no\n        such thing as a perfect solution, there will be always pros and cons.\n      </Paragraph>\n      <Paragraph>\n        Nonetheless, I hope this post has demystified the complexity of state management and you are\n        encouraged to reason about the need of 3rd party solutions for it.\n      </Paragraph>\n      <Paragraph>\n        Check out the <A\n          href=\"https://codesandbox.io/s/demystifying-state-management-79bf7-79bf7\"\n          target=\"_blank\"\n        >\n        codesandbox with the implementation and usage</A>.\n      </Paragraph>\n      <Paragraph>\n        <b>Note</b>: state management of remote data such as Client Graphql provides, it is complex due to its\n        purpose. Graphql aim to solve the combination of multiple data source allowing application\n        to query part of fields in a fast, flexible and developer-friendly way. However, shared states and\n        Rest API resources are quite modular, and simple to retain and update.\n      </Paragraph>\n    </Layout>\n  )\n}"],"sourceRoot":""}