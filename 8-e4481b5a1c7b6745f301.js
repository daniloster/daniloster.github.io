(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{"HnB+":function(e,t,n){"use strict";n.r(t),n.d(t,"default",(function(){return h}));var a=n("q1tI"),r=n.n(a),s=n("vOnD"),o=n("oqi6"),i=n("uzDE"),l=n("DR7b"),u=n("G2tH"),c=n("ebhC"),d="prism",m=s.a.div.withConfig({displayName:"BehindTheStateManagement__Layout",componentId:"ng7st6-0"})([".wrapper{border:1px dotted darkgrey;padding:15px;}.wrapper + .wrapper{margin-top:15px;}.container{position:relative;height:200px;width:200px;background-color:blue;}.container > div{width:100%;background-color:green;}.content-box{box-sizing:content-box;}.padded{padding:10px;}.bordered{border:5px solid red;}.with-margins{margin:10px;}.overflow{overflow:auto;}.border-box{box-sizing:border-box;}"]);function h(e){var t=e.html;return r.a.createElement(m,null,r.a.createElement(l.default,null,t),r.a.createElement(u.default,null,"There are several ways out there to provide a store mechanism to share data in frontend applications in diverse UI frameworks. There is always a trend on new store management that does something slightly different. The goal  of this post is to demystify the “complexity” of state management by implementing one in React."),r.a.createElement(c.default,null,"Reasoning About State"),r.a.createElement(u.default,null,"Let’s understand what an application requires from state management indeed. Maintaining a state imply in providing ways for components and “interested parts” to subscribe to changes, to obtain the current state, and to update it."),r.a.createElement(u.default,null,"Ideally, the store should be a replaceable piece being decoupled from your application."),r.a.createElement(u.default,null,"Now that we understand the basic requirements of a store, why should we implement one while we have several libraries doing it already? There are 2 entangled reasons."),r.a.createElement(u.default,null,"1st. The node environment is extremely polluted causing an application to take huge space on the disk (above 1Gb certainly). Having a large node_modules folder will likely have more files that will be loaded while compiling or running your application, therefore, slowing down some of the development lifecycles (development, testing, building, deplyoing among others) or adding security risks. Then, preventing the usage of unnecessary libraries is essential."),r.a.createElement(u.default,null,"2nd. Not all things we imagine being complex are complex indeed. If you revisit your past there will be things you found complex as hell that make you laugh today. As we experience more challenges and events in life we gather more knowledge and connect some dots making something for a second time easier in some cases. We should only add libraries to the node environment if it is really required, and when the library is solving a complex task. I would ask you to ",r.a.createElement(o.default,{href:"https://signalvnoise.com/posts/3124-give-it-five-minutes",target:"_blank"},"give it 5 minutes")," for this suggestion before stating it is complex."),r.a.createElement(c.default,null,"Design Patterns & Principles"),r.a.createElement(u.default,null,"Based on the requirements described before, we need to provide ways to update and get a value. We have seen a lot of this when studying paradigms such as OOP (Object-Oriented Programming) where we used ",r.a.createElement("strong",null,"encapsulation")," ",r.a.createElement(o.default,{href:"https://medium.com/javascript-scene/encapsulation-in-javascript-26be60e325b4",target:"_blank"},"[1]")," and discretely allowed other parts of the application to ",r.a.createElement("i",null,"get")," and ",r.a.createElement("i",null,"set")," values under certain circumstances of scope."),r.a.createElement(u.default,null,"Making the Glue. Now, the application or different modules need to be notified whenever the store changes. That is where the ",r.a.createElement("strong",null,"Subject (Observer pattern)")," ",r.a.createElement(o.default,{href:"https://www.dottedsquirrel.com/observer-pattern-javascript/",target:"_blank"},"[1]")," ",r.a.createElement(o.default,{href:"https://medium.com/@majdasab/observer-pattern-with-javascript-es6-classes-2a19851e1506",target:"_blank"},"[2]")," comes to the rescue. If you have worked with event-driven applications or observables, you may be familiar with its usage. Creating the “update subject” and notifying all subscribed parts on every valid set will allow components to be in sync with the shared/global data."),r.a.createElement(u.default,null,"Last but not least, the store should have a contract that allows you, as a developer, to replace it at any time. This is the design principle for ",r.a.createElement("strong",null,"DI (Dependency Injection)")," ",r.a.createElement(o.default,{href:"https://medium.com/backticks-tildes/the-s-o-l-i-d-principles-in-pictures-b34ce2f1e898",target:"_blank"},"[1]")," ",r.a.createElement(o.default,{href:"https://itnext.io/dependency-injection-in-react-6fcdbd2005e6",target:"_blank"},"[2]"),". The usage of DI decouples your application from the state making it way easier to replace/upgrade/test in the application."),r.a.createElement(c.default,null,"Implementing State Management"),r.a.createElement(u.default,null,"Now let’s assign theory to practice."),r.a.createElement(u.default,null,"1st. Encapsulation"),r.a.createElement(i.default,{theme:d,code:"\nfunction isValid(value: any): boolean {\n  return value !== undefined && value !== null;\n}\n  \nexport class State<T> {\n  private state: T = null!;\n  \n  constructor(state: T) {\n    this.set(Object.freeze(state));\n  }\n  \n  get = (): T => this.state;\n  \n  set = (state: T): T => {\n    this.state = isValid(state) ? Object.freeze(state) : state;\n    return this.get();\n  };\n}\n        ".trim()}),r.a.createElement(u.default,null,"Here is our state with “get” and “set”. In addition, we make sure the object set is always immutable by freezing it."),r.a.createElement(u.default,null,"2nd. Subject Pattern and Making the Glue."),r.a.createElement(u.default,null,"Creating our Subject class, the mechanism of subscription, and notification."),r.a.createElement(i.default,{theme:d,code:"\nexport class Subject<T> {\n  private subscriptions: Array<Subscription<T>> = [];\n  \n  subscribe = (subscriber: Subscription<T>): Unsubscribe => {\n    const reference = { ...subscriber };\n    this.subscriptions.push(reference);\n    return () => {\n      this.subscriptions = this.subscriptions.filter(\n        (item) => item !== reference\n      );\n    };\n  };\n  \n  next = (value: T) => {\n    this.subscriptions.forEach(({ next }) => void next(value));\n  };\n}\n\nexport type Unsubscribe = () => void;\n  \nexport interface Subscription<T> {\n  next(state: T): void;\n}\n        ".trim()}),r.a.createElement(u.default,null,"Using Subject to make the glue and creating an observable state."),r.a.createElement(i.default,{theme:d,code:'\nimport { State } from "./State";\nimport { Subject, Subscription, Unsubscribe } from "./Subject";\n  \nexport type Transformer<T> = (value: T) => T;\n  \nexport class ObservableState<T> {\n  private state: State<T>;\n  private subject: Subject<T> = new Subject();\n  \n  constructor(value: T) {\n    this.state = new State(value);\n  }\n  \n  get = (): T => this.state.get();\n  \n  set = (transform: Transformer<T>): T => {\n    const oldValue = this.get();\n    const newValue = transform(this.get());\n    const hasChanged = newValue !== oldValue;\n    if (hasChanged) {\n      this.state.set(newValue);\n      // In order to create an async behaviour, let’s make usage of setTimeout\n      setTimeout(() => void this.subject.next(this.get()), 0);\n    }\n    return this.get();\n  };\n  \n  subscribe = (subscription: Subscription<T>): Unsubscribe => {\n    return this.subject.subscribe(subscription);\n  };\n}\n        '.trim()}),r.a.createElement(u.default,null,"That is our observable state created with 3 files. So, how to use it now?"),r.a.createElement(u.default,null,"The usage of the state management mechanism should be defined by a contract, and provided a way to replace it. Typescript can help with the contract and the React.Context handles the replecability with the Dependency Injection."),r.a.createElement(u.default,null,"Contract and Dependency Injection"),r.a.createElement(i.default,{theme:d,code:'\nimport { createContext } from "react";\nimport { ObservableState } from "../core/state/ObservableState";\nimport { PeopleState } from "../model/PeopleState";\n         \nexport const PeopleStateContext = createContext(\n  new ObservableState<PeopleState>({\n    people: []\n  })\n);\n        '.trim()}),r.a.createElement(u.default,null,"Because we define the context with a default valid value, we don’t need to wrap the application with the “","<","Context.Provider value=","{...}",">","”. And you should avoid wrapping the application to facilitate the implementation of tests. When testing, you can wrap the module with any other State matching the contract, allowing you to setup different scenarios for your tests."),r.a.createElement(u.default,null,"At last 2 examples of consumers: as a state, and as a reducer."),r.a.createElement(u.default,null,"As a State."),r.a.createElement(i.default,{theme:d,code:'\nimport { Context, useContext, useEffect, useState } from "react";\nimport { ObservableState, Transformer } from "./ObservableState";\n         \nexport function useObservableState<T>(\n  stateContext: Context<ObservableState<T>>\n): [T, (transform: Transformer<T>) => T] {\n  const observableState = useContext(stateContext);\n  const [state, setState] = useState<T>(observableState.get());\n  \n  useEffect(() => {\n    const unsubscribe = observableState.subscribe({\n      next: (value) => void setState(value)\n    });\n  \n    return unsubscribe;\n  }, [observableState]);\n  \n  // here we want all parts manipulating the state to change the core state\n  // then all other subscribers will get the new value, including this one\n  return [state, observableState.set];\n}\n        '.trim()}),r.a.createElement(u.default,null,"As a Reducer."),r.a.createElement(i.default,{theme:d,code:'\nimport { Context, useCallback, useContext, useEffect, useState } from "react";\nimport { ObservableState } from "./ObservableState";\n  \nexport type ReducerTransformer<T, Action> = (state: T, action: Action) => T;\n         \nexport function useObservableStateReducer<T, Action>(\n  reducer: ReducerTransformer<T, Action>,\n  stateContext: Context<ObservableState<T>>\n): [T, (action: Action) => Action] {\n  const observableState = useContext(stateContext);\n  const [state, setState] = useState<T>(observableState.get());\n  const dispatch = useCallback(\n    (action) => {\n      const transform = (oldState) => {\n        const value = reducer(oldState, action);\n        return value;\n      };\n      observableState.set(transform);\n      return action;\n    },\n    [reducer, observableState]\n  );\n  \n  useEffect(() => {\n    const unsubscribe = observableState.subscribe({\n      next: (value) => void setState(value)\n    });\n  \n    return unsubscribe;\n  }, [observableState]);\n  \n  // very similar to the previous hook, but returning a dispatch function\n  return [state, dispatch];\n}\n        '.trim()}),r.a.createElement(c.default,null,"Behind the State Management Complexity"),r.a.createElement(u.default,null,"Now that we have gone through this journey, I would ask you to sleep on it before defending the complexity of global state or jumping on as a silver bullet definition. In software development, there is no such thing as a perfect solution, there will be always pros and cons."),r.a.createElement(u.default,null,"Nonetheless, I hope this post has demystified the complexity of state management and you are encouraged to reason about the need of 3rd party solutions for it."),r.a.createElement(u.default,null,"Check out the ",r.a.createElement(o.default,{href:"https://codesandbox.io/s/demystifying-state-management-79bf7-79bf7",target:"_blank"},"codesandbox with the implementation and usage"),"."),r.a.createElement(u.default,null,r.a.createElement("b",null,"Note"),": state management of remote data such as Client Graphql provides, it is complex due to its purpose. Graphql aim to solve the combination of multiple data source allowing application to query part of fields in a fast, flexible and developer-friendly way. However, shared states and Rest API resources are quite modular, and simple to retain and update."))}}}]);
//# sourceMappingURL=8-e4481b5a1c7b6745f301.js.map